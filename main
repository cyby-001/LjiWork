import 'package:flutter/material.dart';
import 'package:table_calendar/table_calendar.dart';
import 'package:intl/intl.dart';
import 'package:intl/date_symbol_data_local.dart'; 
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:fl_chart/fl_chart.dart';
import 'package:lunar/lunar.dart'; // ğŸ”¥ å¼•å…¥çœŸå®å†œå†åº“
import 'package:flutter/cupertino.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  initializeDateFormatting().then((_) => runApp(const MoneyCalendarApp()));
}

class MoneyCalendarApp extends StatelessWidget {
  const MoneyCalendarApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'åŠ è–ªæ—¥å† Pro',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: Colors.teal,
        useMaterial3: true,
        scaffoldBackgroundColor: const Color(0xFFF2F5F9),
        cardTheme: const CardThemeData(color: Colors.white, surfaceTintColor: Colors.white),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.grey.shade50,
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: Colors.grey.shade300)),
          enabledBorder: OutlineInputBorder(borderRadius: BorderRadius.circular(8), borderSide: BorderSide(color: Colors.grey.shade300)),
        ),
      ),
      home: const CalendarPage(),
    );
  }
}

// --- ğŸ§± æšä¸¾ä¸åŸºç¡€ç±» ---

enum WorkMode { standard, hourly }
enum RecordType { overtime, leave }
enum LeaveType { compensatory, paid, unpaid, none }

class MoneyItem {
  String name;
  double amount;
  MoneyItem(this.name, this.amount);
  Map<String, dynamic> toJson() => {'n': name, 'a': amount};
  factory MoneyItem.fromJson(Map<String, dynamic> json) => 
      MoneyItem(json['n'], (json['a'] as num).toDouble());
}

class DailyRecord {
  final RecordType type;
  final double hours;
  final double multiplier;
  final LeaveType leaveType;
  final double manualDeduction;
  final String note;

  DailyRecord({
    required this.type,
    required this.hours,
    this.multiplier = 1.0,
    this.leaveType = LeaveType.none,
    this.manualDeduction = 0.0,
    this.note = '',
  });

  Map<String, dynamic> toJson() => {
    't': type.index, 'h': hours, 'm': multiplier, 
    'lt': leaveType.index, 'md': manualDeduction, 'n': note
  };
  
  factory DailyRecord.fromJson(Map<String, dynamic> json) {
    return DailyRecord(
      type: RecordType.values[json['t'] ?? 0],
      hours: (json['h'] as num).toDouble(),
      multiplier: (json['m'] as num).toDouble(),
      leaveType: LeaveType.values[json['lt'] ?? 0],
      manualDeduction: (json['md'] ?? 0).toDouble(),
      note: json['n'] ?? '',
    );
  }
}

class SalaryConfig {
  WorkMode mode;
  double baseSalary;
  double workDays;
  int cycleStartDay;
  List<MoneyItem> additions;
  List<MoneyItem> deductions;

  SalaryConfig({
    this.mode = WorkMode.standard,
    required this.baseSalary,
    required this.workDays,
    required this.cycleStartDay,
    required this.additions,
    required this.deductions,
  });

  factory SalaryConfig.defaultConfig() {
    return SalaryConfig(
      mode: WorkMode.standard,
      baseSalary: 10000,
      workDays: 21.75,
      cycleStartDay: 1,
      additions: [MoneyItem('ç»©æ•ˆ', 2000), MoneyItem('é¤è¡¥', 500)],
      deductions: [MoneyItem('ç¤¾ä¿', 1000), MoneyItem('å…¬ç§¯é‡‘', 1000), MoneyItem('ä¸ªç¨', 500)],
    );
  }

  SalaryConfig copy() {
    return SalaryConfig(
      mode: mode,
      baseSalary: baseSalary,
      workDays: workDays,
      cycleStartDay: cycleStartDay,
      additions: additions.map((e) => MoneyItem(e.name, e.amount)).toList(),
      deductions: deductions.map((e) => MoneyItem(e.name, e.amount)).toList(),
    );
  }

  Map<String, dynamic> toJson() => {
    'mode': mode.index, 'base': baseSalary, 'days': workDays, 'cycle': cycleStartDay,
    'adds': additions.map((e) => e.toJson()).toList(),
    'deds': deductions.map((e) => e.toJson()).toList(),
  };

  factory SalaryConfig.fromJson(Map<String, dynamic> json) {
    return SalaryConfig(
      mode: WorkMode.values[json['mode'] ?? 0],
      baseSalary: (json['base'] as num).toDouble(),
      workDays: (json['days'] as num).toDouble(),
      cycleStartDay: json['cycle'] as int,
      additions: (json['adds'] as List?)?.map((e) => MoneyItem.fromJson(e)).toList() ?? [],
      deductions: (json['deds'] as List?)?.map((e) => MoneyItem.fromJson(e)).toList() ?? [],
    );
  }
}

// --- ğŸ  ä¸»é¡µé¢ ---

class CalendarPage extends StatefulWidget {
  const CalendarPage({super.key});
  @override
  State<CalendarPage> createState() => _CalendarPageState();
}

class _CalendarPageState extends State<CalendarPage> {
  bool _isLoading = true;
  bool _isSalaryHidden = true;
  DateTime _focusedDay = DateTime.now();
  DateTime? _selectedDay;
  Map<String, DailyRecord> _records = {};
  SalaryConfig _globalConfig = SalaryConfig.defaultConfig();
  Map<String, SalaryConfig> _monthlyConfigs = {};
  Map<String, Map<String, double>> _monthlyStatsCache = {};        // æœˆæ”¶å…¥ç¼“å­˜
  Map<String, Map<String, double>> _monthlyOvertimeCache = {};     // æœˆåŠ ç­æ—¶é•¿ç¼“å­˜
  Map<String, List<FlSpot>> _yearlyIncomeCache = {};                // å¹´æ”¶å…¥æŠ˜çº¿å›¾ç¼“å­˜
  Map<String, List<FlSpot>> _yearlyOvertimeCache = {};             // å¹´åŠ ç­æŠ˜çº¿å›¾ç¼“å­˜

  @override
  void initState() {
    super.initState();
    _selectedDay = _focusedDay;
    _loadData();
  }

  String _getDateKey(DateTime date) => DateFormat('yyyy-MM-dd').format(date);
  String _getMonthKey(DateTime date) => DateFormat('yyyy-MM').format(date);

  SalaryConfig _getConfigForMonth(DateTime date) {
    // ç»§æ‰¿é€»è¾‘ï¼šæŸ¥æ‰¾å½“æœˆ -> æŸ¥æ‰¾å‰12ä¸ªæœˆ -> ä½¿ç”¨å…¨å±€
    String currentKey = _getMonthKey(date);
    if (_monthlyConfigs.containsKey(currentKey)) {
      return _monthlyConfigs[currentKey]!;
    }
    
    DateTime checkDate = date;
    for (int i = 0; i < 12; i++) { 
       checkDate = DateTime(checkDate.year, checkDate.month - 1, 1);
       String prevKey = _getMonthKey(checkDate);
       if (_monthlyConfigs.containsKey(prevKey)) {
         return _monthlyConfigs[prevKey]!;
       }
    }

    return _globalConfig;
  }

  DateTimeRange _getCurrentPayCycle(DateTime focus) {
    SalaryConfig cfg = _getConfigForMonth(focus);
    int startDay = cfg.cycleStartDay;
    if (startDay == 1) {
      return DateTimeRange(start: DateTime(focus.year, focus.month, 1), end: DateTime(focus.year, focus.month + 1, 0));
    } else {
      DateTime start = DateTime(focus.year, focus.month - 1, startDay);
      DateTime end = DateTime(focus.year, focus.month, startDay - 1);
      return DateTimeRange(start: start, end: end);
    }
  }

  // --- ğŸ§® å®Œæ•´è®¡ç®—é€»è¾‘ (é€šç”¨ç‰ˆ) ---

  double _getHourlyRate(SalaryConfig cfg) {
    if (cfg.mode == WorkMode.hourly) return cfg.baseSalary;
    return cfg.baseSalary / cfg.workDays / 8.0;
  }
  
  // æ ¸å¿ƒè®¡ç®—æ–¹æ³•ï¼šè®¡ç®—ç‰¹å®šæ—¥æœŸæ‰€åœ¨å‘¨æœŸçš„å·¥èµ„
  Map<String, double> _calculateStatsForDate(DateTime focusDate) {
  String monthKey = _getMonthKey(focusDate);
  
  if (_monthlyStatsCache.containsKey(monthKey)) {
    return _monthlyStatsCache[monthKey]!;
  }

  // ======== ä¸‹é¢æ˜¯ä½ åŸæ¥çš„å…¨éƒ¨è®¡ç®—é€»è¾‘ï¼Œä¸€å­—ä¸åŠ¨ ========
  SalaryConfig cfg = _getConfigForMonth(focusDate);
  DateTimeRange range = _getCurrentPayCycle(focusDate);
  DateTime rangeStart = range.start.subtract(const Duration(seconds: 1));
  DateTime rangeEnd = range.end.add(const Duration(days: 1));
  double hourlyRate = _getHourlyRate(cfg);
  double pool15 = 0, pool20 = 0, pool30 = 0;
  double compLeaveNeeded = 0; 
  double directDeduction = 0;
  double overtimeIncome = 0;

  _records.forEach((key, record) {
    DateTime date = DateTime.parse(key);
    if (date.isAfter(rangeStart) && date.isBefore(rangeEnd)) {
      if (record.type == RecordType.overtime) {
        if (record.multiplier == 1.5) pool15 += record.hours;
        else if (record.multiplier == 2.0) pool20 += record.hours;
        else if (record.multiplier == 3.0) pool30 += record.hours;
        else if (cfg.mode == WorkMode.hourly) overtimeIncome += record.hours * hourlyRate;
      } else if (record.type == RecordType.leave) {
        if (record.leaveType == LeaveType.compensatory) compLeaveNeeded += record.hours;
        else if (record.leaveType == LeaveType.unpaid) {
          directDeduction += (record.manualDeduction > 0) ? record.manualDeduction : (record.hours * hourlyRate);
        }
      }
    }
  });

  if (cfg.mode == WorkMode.standard) {
    double remainingComp = compLeaveNeeded;
    if (remainingComp > 0 && pool15 >= remainingComp) { pool15 -= remainingComp; remainingComp = 0; } 
    else if (remainingComp > 0) { remainingComp -= pool15; pool15 = 0; }
    if (remainingComp > 0 && pool20 >= remainingComp) { pool20 -= remainingComp; remainingComp = 0; } 
    else if (remainingComp > 0) { remainingComp -= pool20; pool20 = 0; }
    if (remainingComp > 0) directDeduction += remainingComp * hourlyRate;
    overtimeIncome = (pool15 * hourlyRate * 1.5) + (pool20 * hourlyRate * 2.0) + (pool30 * hourlyRate * 3.0);
  }

  double extraAdditions = cfg.additions.fold(0, (sum, item) => sum + item.amount);
  double extraDeductions = cfg.deductions.fold(0, (sum, item) => sum + item.amount);
  double baseIncome = (cfg.mode == WorkMode.standard) ? cfg.baseSalary : 0;
  double totalIncome = baseIncome + extraAdditions + overtimeIncome - directDeduction - extraDeductions;
  
  final result = {
    'total': totalIncome,
    'base': baseIncome,
    'adds': extraAdditions,
    'overtime': overtimeIncome,
    'deduct': directDeduction + extraDeductions,
  };
  // ======== ç¼“å­˜ç»“æœ ========
  _monthlyStatsCache[monthKey] = result;
  if (_monthlyStatsCache.length > 24) {
    // åªä¿ç•™æœ€è¿‘24ä¸ªæœˆ
    _monthlyStatsCache.remove(_monthlyStatsCache.keys.first);
  }
  return result;
}
  // ğŸ†• ç»Ÿè®¡ç‰¹å®šæœˆä»½çš„åŠ ç­æ—¶é•¿
Map<String, double> _calculateOvertimeHours(DateTime focusDate) {
  String monthKey = _getMonthKey(focusDate);
  if (_monthlyOvertimeCache.containsKey(monthKey)) {
    return _monthlyOvertimeCache[monthKey]!;
  }

  DateTimeRange range = _getCurrentPayCycle(focusDate);
  DateTime rangeStart = range.start.subtract(const Duration(seconds: 1));
  DateTime rangeEnd = range.end.add(const Duration(days: 1));
  
  double pool15 = 0, pool20 = 0, pool30 = 0, totalHours = 0;

  _records.forEach((key, record) {
    DateTime date = DateTime.parse(key);
    if (date.isAfter(rangeStart) && date.isBefore(rangeEnd) && record.type == RecordType.overtime) {
      totalHours += record.hours;
      if (record.multiplier == 1.5) pool15 += record.hours;
      else if (record.multiplier == 2.0) pool20 += record.hours;
      else if (record.multiplier == 3.0) pool30 += record.hours;
    }
  });

  final result = {'total': totalHours, '1.5x': pool15, '2.0x': pool20, '3.0x': pool30};
  _monthlyOvertimeCache[monthKey] = result;
  if (_monthlyOvertimeCache.length > 24) _monthlyOvertimeCache.remove(_monthlyOvertimeCache.keys.first);
  return result;
}

// ğŸ†• è®¡ç®—ä¸€æ•´å¹´çš„æ€»åŠ ç­æ—¶é•¿ï¼ˆç”¨äºå¹´åº¦å›¾è¡¨ï¼‰
List<FlSpot> _calculateYearlyOvertime(int year) {
  String key = 'ot_$year';
  if (_yearlyOvertimeCache.containsKey(key)) return _yearlyOvertimeCache[key]!;

  List<FlSpot> spots = [];
  int maxMonth = (year == DateTime.now().year) ? DateTime.now().month : 12;

  for (int m = 1; m <= maxMonth; m++) {
    DateTime d = DateTime(year, m, 15);
    double total = _calculateOvertimeHours(d)['total'] ?? 0;
    spots.add(FlSpot(m.toDouble(), total));
  }

  _yearlyOvertimeCache[key] = spots;
  return spots;
}
  
  // ä¸ºæ—¥å†ä¸»é¡µæä¾›å½“å‰ç„¦ç‚¹çš„ç»Ÿè®¡ (è°ƒç”¨é€šç”¨æ–¹æ³•)
  Map<String, double> _calculateStats() {
      return _calculateStatsForDate(_focusedDay);
  }

  // ğŸ†• è®¡ç®—ä¸€æ•´å¹´çš„ç»Ÿè®¡æ•°æ®ï¼ˆç”¨äºå›¾è¡¨ï¼‰
  List<FlSpot> _calculateYearlyStats(int year) {
  String key = 'income_$year';
  if (_yearlyIncomeCache.containsKey(key)) return _yearlyIncomeCache[key]!;

  List<FlSpot> spots = [];
  int maxMonth = (year == DateTime.now().year) ? DateTime.now().month : 12;

  for (int m = 1; m <= maxMonth; m++) {
    DateTime d = DateTime(year, m, 15);
    double total = _calculateStatsForDate(d)['total'] ?? 0;
    spots.add(FlSpot(m.toDouble(), total));
  }

  _yearlyIncomeCache[key] = spots;
  return spots;
}

  Future<void> _loadData() async {
    final prefs = await SharedPreferences.getInstance();
    try {
      String? recStr = prefs.getString('records_v6');
      if (recStr != null) {
        Map<String, dynamic> map = json.decode(recStr);
        _records = map.map((k, v) => MapEntry(k, DailyRecord.fromJson(v)));
      }
      String? globalStr = prefs.getString('global_config_v6');
      if (globalStr != null) _globalConfig = SalaryConfig.fromJson(json.decode(globalStr));

      String? monthsStr = prefs.getString('monthly_configs_v6');
      if (monthsStr != null) {
        Map<String, dynamic> map = json.decode(monthsStr);
        _monthlyConfigs = map.map((k, v) => MapEntry(k, SalaryConfig.fromJson(v)));
      }

      String? hidden = prefs.getString('salary_hidden');
      if (hidden != null) {
        _isSalaryHidden = hidden == 'true';
      }
    } catch (e) {
      debugPrint("Error: $e");
    } finally {
      setState(() => _isLoading = false);
    }
  }

  Future<void> _saveData() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('records_v6', json.encode(_records));
    await prefs.setString('global_config_v6', json.encode(_globalConfig));
    await prefs.setString('monthly_configs_v6', json.encode(_monthlyConfigs));
    await prefs.setString('salary_hidden', _isSalaryHidden.toString());
  }

  void _showAddSheet() {
    String key = _getDateKey(_selectedDay!);
    RecordType currentType = RecordType.overtime;
    double multiplier = (_selectedDay!.weekday >= 6) ? 2.0 : 1.5;
    LeaveType leaveType = LeaveType.compensatory;
    double hours = 0.0;
    double manualDed = 0.0;
    String note = "";
    if (_records.containsKey(key)) {
      var r = _records[key]!;
      currentType = r.type;
      hours = r.hours;
      multiplier = r.multiplier;
      leaveType = r.leaveType;
      manualDed = r.manualDeduction;
      note = r.note;
    }

    FixedExtentScrollController scrollController = FixedExtentScrollController(initialItem: (hours / 0.5).round());
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setSheetState) {
            final List<double> quickTimes = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0, 6.0, 8.0, 9.0, 10.0, 12.0];
            return Padding(
              padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
              child: Container(
                padding: const EdgeInsets.all(24),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text("${_selectedDay!.month}æœˆ${_selectedDay!.day}æ—¥", style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
                            Text(_records.containsKey(key) ? "ç¼–è¾‘è®°å½•" : "æ–°å»ºè®°å½•", style: const TextStyle(fontSize: 12, color: Colors.grey)),
                          ],
                        ),
                        const Spacer(),
                        if (_records.containsKey(key))
                          IconButton(
                            onPressed: () {
                              setState(() => _records.remove(key));
                              _saveData().then((_) => _clearAllCaches());
                              Navigator.pop(context);
                            }, 
                            icon: const Icon(Icons.delete_outline, color: Colors.red, size: 28),
                          )
                      ],
                    ),
                    const SizedBox(height: 20),
                    Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(color: Colors.grey.shade100, borderRadius: BorderRadius.circular(16)),
                      child: Row(
                        children: [
                          _buildTabBtn("åŠ ç­", currentType == RecordType.overtime, () => setSheetState(() => currentType = RecordType.overtime)),
                          _buildTabBtn("è¯·å‡/è°ƒä¼‘", currentType == RecordType.leave, () => setSheetState(() => currentType = RecordType.leave)),
                        ],
                      ),
                    ),
                    const SizedBox(height: 20),
                    if (currentType == RecordType.overtime)
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceAround,
                        children: [
                          _buildChip("1.5å€", multiplier == 1.5, () => setSheetState(() => multiplier = 1.5)),
                          _buildChip("2.0å€", multiplier == 2.0, () => setSheetState(() => multiplier = 2.0)),
                          _buildChip("3.0å€", multiplier == 3.0, () => setSheetState(() => multiplier = 3.0)),
                        ],
                      )
                    else
                      Wrap(spacing: 12, children: [
                          _buildChip("è°ƒä¼‘", leaveType == LeaveType.compensatory, () => setSheetState(() => leaveType = LeaveType.compensatory)),
                          _buildChip("äº‹å‡", leaveType == LeaveType.unpaid, () => setSheetState(() => leaveType = LeaveType.unpaid)),
                          _buildChip("å¸¦è–ª", leaveType == LeaveType.paid, () => setSheetState(() => leaveType = LeaveType.paid)),
                      ]),
                    
                    const SizedBox(height: 25),
                    SizedBox(
                      height: 45,
                      child: ListView.separated(
                        scrollDirection: Axis.horizontal,
                        itemCount: quickTimes.length,
                        separatorBuilder: (c, i) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          double t = quickTimes[index];
                          bool isSel = hours == t;
                          return GestureDetector(
                            onTap: () {
                              setSheetState(() {
                                hours = t;
                                scrollController.jumpToItem((t / 0.5).round());
                              });
                            },
                            child: Container(
                              alignment: Alignment.center,
                              padding: const EdgeInsets.symmetric(horizontal: 20),
                              decoration: BoxDecoration(
                                color: isSel ? Colors.teal : Colors.white,
                                border: Border.all(color: isSel ? Colors.teal : Colors.grey.shade300),
                                borderRadius: BorderRadius.circular(24),
                              ),
                              child: Text("$t", style: TextStyle(color: isSel ? Colors.white : Colors.black87, fontWeight: FontWeight.bold, fontSize: 16)),
                            ),
                          );
                        },
                      ),
                    ),
                    const SizedBox(height: 20),
                    SizedBox(
                        height: 150,
                        child: CupertinoPicker(
                          scrollController: scrollController, // åŸæ¥çš„ controller ç»§ç»­ç”¨
                          itemExtent: 50,
                          diameterRatio: 1.2,
                          magnification: 1.3,
                          useMagnifier: true,
                          backgroundColor: Colors.transparent,
                          onSelectedItemChanged: (index) {
                            setSheetState(() {
                              hours = index * 0.5;
                            });
                          },
                          children: List.generate(49, (index) {
                            final double val = index * 0.5;
                            final bool isSelected = val == hours;

                            return Center(
                              child: Text(
                                val == 0 ? "0" : val.toStringAsFixed(1),
                                style: TextStyle(
                                  fontSize: isSelected ? 36 : 24,
                                  fontWeight: isSelected ? FontWeight.bold : FontWeight.w500,
                                  color: isSelected ? Colors.teal.shade700 : Colors.grey.shade600,
                                  height: 1,
                                ),
                              ),
                            );
                          }),
                        ),
                      ),

                    if (currentType == RecordType.leave && leaveType == LeaveType.unpaid)
                       TextFormField(
                         initialValue: manualDed > 0 ? manualDed.toString() : '',
                         decoration: const InputDecoration(labelText: "æ‰£æ¬¾é‡‘é¢ (å¯é€‰)", prefixText: "Â¥ "),
                         keyboardType: TextInputType.number,
                         onChanged: (v) => manualDed = double.tryParse(v) ?? 0,
                       ),
                    
                    const SizedBox(height: 10),
                    TextFormField(
                      initialValue: note,
                      decoration: const InputDecoration(labelText: "å¤‡æ³¨", prefixIcon: Icon(Icons.edit_note), border: UnderlineInputBorder()),
                      onChanged: (v) => note = v,
                    ),

                    const SizedBox(height: 20),
                    SizedBox(
                      width: double.infinity, height: 54,
                      child: ElevatedButton(
                        onPressed: () {
                          if (hours > 0) {
                            setState(() {
                              _records[key] = DailyRecord(
                                type: currentType, hours: hours, multiplier: multiplier,
                                leaveType: leaveType, manualDeduction: manualDed, note: note,
                              );
                            });
                            _saveData().then((_) => _clearAllCaches());
                            Navigator.pop(context);
                          }
                        },
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.teal, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16))),
                        child: const Text("ä¿å­˜è®°å½•", style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)),
                      ),
                    )
                  ],
                ),
              ),
            );
          }
        );
      }
    );
  }

  Widget _buildTabBtn(String label, bool active, VoidCallback onTap) {
    return Expanded(
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.symmetric(vertical: 12),
          decoration: BoxDecoration(
            color: active ? Colors.white : Colors.transparent,
            borderRadius: BorderRadius.circular(14),
            boxShadow: active ? [BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 4, offset: const Offset(0, 2))] : [],
          ),
          child: Text(label, style: TextStyle(fontWeight: FontWeight.bold, color: active ? Colors.black : Colors.grey)),
        ),
      ),
    );
  }

  Widget _buildChip(String label, bool active, VoidCallback onTap) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: active ? Colors.teal.shade50 : Colors.grey.shade50,
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: active ? Colors.teal : Colors.grey.shade300)
        ),
        child: Text(label, style: TextStyle(color: active ? Colors.teal.shade800 : Colors.black87, fontWeight: active ? FontWeight.bold : FontWeight.normal)),
      ),
    );
  }

  void _showSettingsDialog() {
    String currentMonthKey = _getMonthKey(_focusedDay);
    SalaryConfig editingConfig = _getConfigForMonth(_focusedDay).copy();
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setSheetState) {
            return Padding(
              padding: EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
              child: Container(
                constraints: BoxConstraints(maxHeight: MediaQuery.of(context).size.height * 0.9),
                padding: const EdgeInsets.fromLTRB(24, 24, 24, 0),
                child: Column(
                  children: [
                    Text("è–ªèµ„é…ç½® (${_focusedDay.month}æœˆ)", style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
                    const Text("æœ¬æœˆé…ç½®ç‹¬ç«‹ï¼Œä¿®æ”¹ä¸å½±å“å…¶ä»–æœˆä»½", style: TextStyle(fontSize: 10, color: Colors.grey)),
                    const SizedBox(height: 20),
                    Expanded(
                      child: ListView(
                        children: [
                          DropdownButtonFormField<WorkMode>(
                            value: editingConfig.mode,
                            // è°ƒæ•´ contentPadding è®©æ–‡æœ¬æ›´é ä¸Šï¼Œé¿å…é®æŒ¡ 
                            decoration: const InputDecoration(
                              labelText: "å·¥ä½œæ¨¡å¼",
                              contentPadding: EdgeInsets.fromLTRB(12, 12, 12, 12), // è°ƒæ•´ä¸Šä¸‹ padding
                            ),
                            items: const [
                              DropdownMenuItem(value: WorkMode.standard, child: Text("æ­£å¼å·¥ (æœˆè–ª)")),
                              DropdownMenuItem(value: WorkMode.hourly, child: Text("å°æ—¶å·¥ (æ—¶è–ª)")),
                            ],
                            onChanged: (v) => setSheetState(() => editingConfig.mode = v!),
                          ),
                          const SizedBox(height: 15),

                          TextFormField(
                            initialValue: editingConfig.baseSalary.toString(),
                            decoration: InputDecoration(labelText: editingConfig.mode == WorkMode.standard ? "æœˆè–ª (åº•è–ª)" : "åŸºç¡€æ—¶è–ª", prefixText: "Â¥ "),
                            keyboardType: TextInputType.number,
                            onChanged: (v) => editingConfig.baseSalary = double.tryParse(v) ?? 0,
                          ),
                          
                          if (editingConfig.mode == WorkMode.standard) ...[
                            const SizedBox(height: 15),
                            TextFormField(
                              initialValue: editingConfig.workDays.toString(),
                              decoration: const InputDecoration(labelText: "è®¡è–ªå¤©æ•° (é»˜è®¤21.75)"),
                              keyboardType: TextInputType.number,
                              onChanged: (v) => editingConfig.workDays = double.tryParse(v) ?? 21.75,
                            ),
                            
                            const Divider(height: 40),
                            _buildListHeader("é¢å¤–æ”¶å…¥ (ç»©æ•ˆ/è¡¥è´´)", () => setSheetState(() => editingConfig.additions.add(MoneyItem("æ–°é¡¹ç›®", 0)))),
                            ...editingConfig.additions.asMap().entries.map((e) => _buildMoneyItemRow(e.value, (item) => setSheetState(() => editingConfig.additions.removeAt(e.key)))),

                            const SizedBox(height: 10),
                            _buildListHeader("å›ºå®šæ‰£æ¬¾ (ç¤¾ä¿/å…¬ç§¯é‡‘)", () => setSheetState(() => editingConfig.deductions.add(MoneyItem("æ–°æ‰£æ¬¾", 0)))),
                            ...editingConfig.deductions.asMap().entries.map((e) => _buildMoneyItemRow(e.value, (item) => setSheetState(() => editingConfig.deductions.removeAt(e.key)))),
                          ],

                          const Divider(height: 40),
                          const Text("å‘¨æœŸè®¾ç½®", style: TextStyle(fontWeight: FontWeight.bold)),
                          Slider(
                            value: editingConfig.cycleStartDay.toDouble(),
                            min: 1, max: 28, divisions: 27,
                            label: "${editingConfig.cycleStartDay}å·",
                            activeColor: Colors.teal,
                            onChanged: (v) => setSheetState(() => editingConfig.cycleStartDay = v.toInt()),
                          ),
                          Text("æ¯æœˆ ${editingConfig.cycleStartDay} å·å¼€å§‹"),
                          const SizedBox(height: 60),
                        ],
                      ),
                    ),
                    ElevatedButton(
                      onPressed: () {
                        setState(() {
                          _monthlyConfigs[currentMonthKey] = editingConfig;
                        });
                        _saveData().then((_) => _clearAllCaches());
                        Navigator.pop(context);
                      },
                      style: ElevatedButton.styleFrom(backgroundColor: Colors.teal, minimumSize: const Size.fromHeight(50)),
                      child: const Text("ä¿å­˜æœ¬æœˆé…ç½®", style: TextStyle(color: Colors.white, fontSize: 16)),
                    ),
                    const SizedBox(height: 20),
                  ],
                ),
              ),
            );
          }
        );
      }
    );
  }
  // 4. æ–°å¢ä¸€ä¸ªç»Ÿä¸€æ¸…ç†æ–¹æ³•
  void _clearAllCaches() {
    _monthlyStatsCache.clear();
    _monthlyOvertimeCache.clear();
    _yearlyIncomeCache.clear();
    _yearlyOvertimeCache.clear();
  }

  void _showStatsDialog() {
  final currentStats = _calculateStats(); 
  final currentOvertime = _calculateOvertimeHours(_focusedDay); 
  final overtimeDays = _calculateOvertimeDays(_focusedDay); // ğŸ†• è·å–æœ¬æœˆåŠ ç­å¤©æ•°
  
  showDialog(
    context: context,
    builder: (context) => StatsDialog(
      currentMonthStats: currentStats,
      currentOvertime: currentOvertime,
      overtimeDays: overtimeDays, // ğŸ†• ä¼ é€’åŠ ç­å¤©æ•°
      yearlyStatsCalculator: _calculateYearlyStats, 
      yearlyOvertimeCalculator: _calculateYearlyOvertime, 
      focusedDate: _focusedDay,
    ),
  );
}

  Widget _buildListHeader(String title, VoidCallback onAdd) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        TextButton.icon(onPressed: onAdd, icon: const Icon(Icons.add_circle_outline, size: 16), label: const Text("æ·»åŠ "), style: TextButton.styleFrom(visualDensity: VisualDensity.compact))
      ],
    );
  }

  Widget _buildMoneyItemRow(MoneyItem item, Function(MoneyItem) onDelete) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          Expanded(flex: 3, child: TextFormField(initialValue: item.name, decoration: const InputDecoration(contentPadding: EdgeInsets.symmetric(horizontal: 10)), onChanged: (v) => item.name = v)),
          const SizedBox(width: 8),
          Expanded(flex: 3, child: TextFormField(initialValue: item.amount == 0 ? '' : item.amount.toString(), decoration: const InputDecoration(prefixText: "Â¥", contentPadding: EdgeInsets.symmetric(horizontal: 10)), keyboardType: TextInputType.number, onChanged: (v) => item.amount = double.tryParse(v) ?? 0)),
          IconButton(onPressed: () => onDelete(item), icon: const Icon(Icons.remove_circle, color: Colors.red, size: 20), constraints: const BoxConstraints(), padding: const EdgeInsets.only(left: 8))
        ],
      ),
    );
  }

@override
  Widget build(BuildContext context) {
    if (_isLoading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    final stats = _calculateStats();
    DateTimeRange cycle = _getCurrentPayCycle(_focusedDay);

    return Scaffold(
      appBar: AppBar(
        title: const Text('åŠ è–ªæ—¥å†', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        backgroundColor: Colors.teal,
        actions: [
          IconButton(
              icon: const Icon(Icons.bar_chart, color: Colors.white),
              onPressed: _showStatsDialog,
              tooltip: "ç»Ÿè®¡",
          ),
          IconButton(icon: const Icon(Icons.settings, color: Colors.white), onPressed: _showSettingsDialog)
        ],
      ),
      body: Column(
        children: [
          Container(
            padding: const EdgeInsets.fromLTRB(24, 10, 24, 30),
            decoration: const BoxDecoration(
              gradient: LinearGradient(colors: [Colors.teal, Color(0xFF00695C)]),
              borderRadius: BorderRadius.vertical(bottom: Radius.circular(30)),
            ),
            child: Column(
              children: [
                Text("${cycle.start.month}.${cycle.start.day} - ${cycle.end.month}.${cycle.end.day}", style: const TextStyle(color: Colors.white70)),
                const SizedBox(height: 20),
                Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        _isSalaryHidden ? "Â¥ â€¢â€¢â€¢â€¢" : "Â¥ ${stats['total']!.toStringAsFixed(2)}",
                        style: const TextStyle(color: Colors.white, fontSize: 36, fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(width: 8),
                      GestureDetector(
                        onTap: () => setState(() {
                          _isSalaryHidden = !_isSalaryHidden;
                          _saveData(); 
                        }),
                        child: Icon(_isSalaryHidden ? Icons.visibility_off : Icons.visibility, color: Colors.white70, size: 28),
                      ),
                    ],
                  ),
                const SizedBox(height: 20),
                // ğŸ”¥ æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ Visibility ä¿æŒ Row çš„ç©ºé—´ï¼Œé¿å… UI è·³åŠ¨
                Visibility(
                  visible: !_isSalaryHidden, // ä»…åœ¨æœªéšè—æ—¶å¯è§
                  maintainSize: true,        // å³ä½¿ä¸å¯è§ä¹Ÿä¿æŒç©ºé—´å¤§å° (è§£å†³æ”¶ç¼©é—®é¢˜)
                  maintainAnimation: true,
                  maintainState: true,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      _buildHeaderStat("åº•è–ª+ç»©æ•ˆ", (stats['base']! + stats['adds']!).toStringAsFixed(0)),
                      _buildHeaderStat("åŠ ç­è´¹", "+${stats['overtime']!.toStringAsFixed(0)}"),
                      _buildHeaderStat("æ‰£é™¤", "-${stats['deduct']!.toStringAsFixed(0)}"),
                    ],
                  ),
                )
              ],
            ),
          ),
          Expanded(
            child: CustomScrollView(
              slivers: [
                SliverPadding(
                  padding: const EdgeInsets.all(16),
                  sliver: SliverList(
                    delegate: SliverChildListDelegate([
                      Card(
                        elevation: 2,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                        child: TableCalendar(
                          locale: 'zh_CN',
                          firstDay: DateTime.utc(2020, 1, 1),
                          lastDay: DateTime.utc(2035, 12, 31),
                          focusedDay: _focusedDay,
                          currentDay: DateTime.now(),
                          availableCalendarFormats: const {CalendarFormat.month: ''},
                          headerStyle: const HeaderStyle(
                            formatButtonVisible: false,
                            titleCentered: true,
                            titleTextStyle: TextStyle(color: Colors.black87, fontSize: 18, fontWeight: FontWeight.bold),
                          ),
                          selectedDayPredicate: (day) => isSameDay(_selectedDay, day),
                          onDaySelected: (s, f) => setState(() { _selectedDay = s; _focusedDay = f; }),
                          onPageChanged: (f) => setState(() => _focusedDay = f),
                          rowHeight: 65,
                          calendarStyle: const CalendarStyle(outsideDaysVisible: false),
                          // å…³é”®ä¸€è¡Œï¼è®©æ—¥å†æŠŠæ»‘åŠ¨äº‹ä»¶äº¤ç»™çˆ¶å±‚
                          calendarBuilders: CalendarBuilders(
                            defaultBuilder: (c, day, f) => _buildCell(day, isSelected: false, isToday: false),
                            selectedBuilder: (c, day, f) => _buildCell(day, isSelected: true, isToday: false),
                            todayBuilder: (c, day, f) => _buildCell(day, isSelected: false, isToday: true),
                            markerBuilder: (context, date, events) { String key = _getDateKey(date);
                        if (_records.containsKey(key)) {
                          final rec = _records[key]!;
                          bool isOT = rec.type == RecordType.overtime;
                          String text = isOT ? "+${rec.hours}" : "-${rec.hours}";
                          Color color = isOT ? (rec.multiplier >= 2 ? Colors.red : Colors.blue) : Colors.green;
                          
                          return Positioned(
                            bottom: 2, 
                            child: Text(text, style: TextStyle(color: color, fontSize: 10, fontWeight: FontWeight.bold)),
                          );
                        }
                        return null; },
                          ),
                        ),
                      ),
                      const SizedBox(height: 20),
                      if (_selectedDay != null) _buildDayDetail(),
                      const SizedBox(height: 80),
                    ]),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddSheet,
        backgroundColor: Colors.teal,
        child: const Icon(Icons.add, color: Colors.white),
      ),
    );
  }
  final Map<String, Widget> _cellCache = {};
  // ğŸ”¥ æ ¸å¿ƒæ›´æ–°ï¼šä½¿ç”¨çœŸå®çš„ Lunar åº“æ¸²æŸ“å†œå†
  Widget _buildCell(DateTime day, {required bool isSelected, required bool isToday}) {
    final String key = "${day.year}-${day.month}-${day.day}-$isSelected-$isToday";
    
    return _cellCache.putIfAbsent(key, () {
    final Lunar lunar = Lunar.fromDate(day); // åªåˆ›å»ºä¸€æ¬¡ï¼
    String lunarText = lunar.getDayInChinese();
    Color lunarColor = Colors.grey.shade500;

    List<String> festivals = lunar.getFestivals();
    if (festivals.isNotEmpty) {
      lunarText = festivals[0];
      lunarColor = Colors.teal;
    } else {
      String jieQi = lunar.getJieQi();
      if (jieQi.isNotEmpty) {
        lunarText = jieQi;
        lunarColor = Colors.teal.shade700;
      } else if (lunar.getDay() == 1) {
        lunarText = "${lunar.getMonthInChinese()}æœˆ";
        lunarColor = Colors.teal;
      }
    }

    return Column(
      mainAxisAlignment: MainAxisAlignment.start,
      children: [
        const SizedBox(height: 8),
        Container(
          width: 32,
          height: 32,
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color: isSelected ? Colors.teal : (isToday ? Colors.teal.withOpacity(0.3) : null),
            shape: BoxShape.circle,
          ),
          child: Text(
            '${day.day}',
            style: TextStyle(
              color: isSelected ? Colors.white : (isToday ? Colors.teal : Colors.black87),
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        Text(
          lunarText,
          style: TextStyle(fontSize: 9, color: isSelected ? Colors.teal.shade100 : lunarColor),
        ),
      ],
    );
  });
}

  Widget _buildDayDetail() {
    String key = _getDateKey(_selectedDay!);
    DailyRecord? record = _records[key];
    SalaryConfig cfg = _getConfigForMonth(_focusedDay);
    double rate = _getHourlyRate(cfg);
    return Container(
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(20), border: Border.all(color: Colors.grey.shade200)),
      child: Row(
        children: [
          Icon(
            record == null ? Icons.calendar_today : (record.type == RecordType.overtime ? Icons.access_time_filled : Icons.beach_access),
            color: record == null ? Colors.grey : Colors.teal,
            size: 32,
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (record == null)
                  const Text("æ— è®°å½•", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold))
                else ...[
                  Text(
                    record.type == RecordType.overtime 
                      ? "åŠ ç­ ${record.hours}h (${record.multiplier}å€)" 
                      : "è¯·å‡ ${record.hours}h (${_getLeaveText(record.leaveType)})",
                    style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)
                  ),
                  if (record.note.isNotEmpty)
                    Text(record.note, style: const TextStyle(color: Colors.grey, fontSize: 12), overflow: TextOverflow.ellipsis),
                ]
              ],
            ),
          ),
          if (record != null && record.type == RecordType.overtime)
            Text("+Â¥${(record.hours * rate * record.multiplier).toStringAsFixed(1)}", style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.orange)),
        ],
      ),
    );
  }

  String _getLeaveText(LeaveType type) {
    switch (type) {
      case LeaveType.compensatory: return "è°ƒä¼‘";
      case LeaveType.paid: return "å¸¦è–ª";
      case LeaveType.unpaid: return "äº‹å‡";
      default: return "";
    }
  }

  Widget _buildHeaderStat(String label, String val) {
    return Column(children: [
      Text(val, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16)),
      Text(label, style: const TextStyle(color: Colors.white70, fontSize: 10)),
    ]);
  }
  // ğŸ†• ç»Ÿè®¡ç‰¹å®šæœˆä»½çš„åŠ ç­å¤©æ•°
int _calculateOvertimeDays(DateTime focusDate) {
    DateTimeRange range = _getCurrentPayCycle(focusDate);
    DateTime rangeStart = range.start.subtract(const Duration(seconds: 1));
    DateTime rangeEnd = range.end.add(const Duration(days: 1));
    
    int overtimeDays = 0;

    _records.forEach((key, record) {
        DateTime date = DateTime.parse(key);
        if (date.isAfter(rangeStart) && date.isBefore(rangeEnd)) {
            // åªè¦è¿™ä¸€å¤©æœ‰åŠ ç­è®°å½•ï¼Œå°±ç®—ä¸€å¤©
            if (record.type == RecordType.overtime && record.hours > 0) {
                overtimeDays++;
            }
        }
    });
    
    return overtimeDays;
}
}
// ä»è¿™é‡Œå¼€å§‹æ›¿æ¢æ–‡ä»¶æœ«å°¾çš„æ•´ä¸ª StatsDialog ç±»å®šä¹‰

class StatsDialog extends StatefulWidget {
  final Map<String, double> currentMonthStats;
  final Map<String, double> currentOvertime; 
  final int overtimeDays; // ğŸ†• æ–°å¢ï¼šåŠ ç­å¤©æ•°
  final List<FlSpot> Function(int year) yearlyStatsCalculator;
  final List<FlSpot> Function(int year) yearlyOvertimeCalculator; 
  final DateTime focusedDate;

  const StatsDialog({
    super.key,
    required this.currentMonthStats,
    required this.currentOvertime,
    required this.overtimeDays, // ğŸ†•
    required this.yearlyStatsCalculator,
    required this.yearlyOvertimeCalculator,
    required this.focusedDate,
  });

  @override
  State<StatsDialog> createState() => _StatsDialogState();
}

enum StatView { income, overtime } // è§†å›¾åˆ‡æ¢ï¼šæ”¶å…¥ vs åŠ ç­

class _StatsDialogState extends State<StatsDialog> {
  StatView _currentView = StatView.income; 
  late int _selectedYear;

  @override
  void initState() {
    super.initState();
    _selectedYear = widget.focusedDate.year;
  }
  
  // ç”¨äºæ¸²æŸ“æœˆåº¦ç»Ÿè®¡çš„ç®€è¦å¡ç‰‡
  Widget _buildStatItem(String label, String value, Color color) {
    return Column(
      children: [
        Text(value, style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: color)),
        const SizedBox(height: 4),
        Text(label, style: const TextStyle(color: Colors.grey, fontSize: 12)),
      ],
    );
  }

  // ç”¨äºå¹´åº¦é€‰æ‹©çš„æŒ‰é’®
  Widget _buildYearSelector(String title) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        IconButton(
          icon: const Icon(Icons.chevron_left),
          onPressed: () => setState(() => _selectedYear--),
        ),
        Text(
          "$_selectedYear $title",
          style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        IconButton(
          icon: const Icon(Icons.chevron_right),
          onPressed: _selectedYear < DateTime.now().year ? () => setState(() => _selectedYear++) : null, 
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final currentStats = widget.currentMonthStats;
    final currentOvertime = widget.currentOvertime;
    final cycleMonth = widget.focusedDate.month;

    final isIncomeView = _currentView == StatView.income;
    final yearlySpots = isIncomeView
        ? widget.yearlyStatsCalculator(_selectedYear)
        : widget.yearlyOvertimeCalculator(_selectedYear);

    double maxY = yearlySpots.isNotEmpty
        ? yearlySpots.map((s) => s.y).reduce((a, b) => a > b ? a : b) * 1.1
        : (isIncomeView ? 20000 : 100);

    return Dialog.fullscreen(
      backgroundColor: const Color(0xFFF8FAFD),
      child: SafeArea(
        child: Column(
          children: [
            // é¡¶éƒ¨æ ‡é¢˜æ 
            Padding(
              padding: const EdgeInsets.fromLTRB(20, 10, 16, 10),
              child: Row(
                children: [
                  const Text(
                    'ç»Ÿè®¡åˆ†æ',
                    style: TextStyle(fontSize: 21, fontWeight: FontWeight.bold),
                  ),
                  const Spacer(),
                  IconButton(
                    icon: const Icon(Icons.close_rounded),
                    onPressed: () => Navigator.pop(context),
                  ),
                ],
              ),
            ),

            // æ”¶å…¥ / åŠ ç­ åˆ‡æ¢æŒ‰é’®
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 20),
              padding: const EdgeInsets.all(4),
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(16),
              ),
              child: Row(
                children: [
                  _buildTabBtn("æ”¶å…¥åˆ†æ", isIncomeView, () => setState(() => _currentView = StatView.income)),
                  _buildTabBtn("åŠ ç­ç»Ÿè®¡", !isIncomeView, () => setState(() => _currentView = StatView.overtime)),
                ],
              ),
            ),

            const SizedBox(height: 20),

            // ä¸»ä½“å†…å®¹ï¼ˆå¯æ»šåŠ¨ï¼‰
            Expanded(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Column(
                  children: [
                    if (isIncomeView)
                      _buildIncomeView(currentStats, yearlySpots, maxY, cycleMonth)
                    else
                      _buildOvertimeView(currentOvertime, yearlySpots, maxY, cycleMonth),

                    const SizedBox(height: 30),
                    // å…³é—­æŒ‰é’®ï¼ˆæ”¾åœ¨åº•éƒ¨æ›´èˆ’æœï¼‰
                    SizedBox(
                      width: double.infinity,
                      height: 52,
                      child: ElevatedButton(
                        onPressed: () => Navigator.pop(context),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.teal,
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                        ),
                        child: const Text("å…³é—­", style: TextStyle(fontSize: 17, color: Colors.white)),
                      ),
                    ),
                    const SizedBox(height: 20),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  // æ”¶å…¥è§†å›¾
  Widget _buildIncomeView(Map<String, double> stats, List<FlSpot> yearlySpots, double maxY, int month) {
    return Column(
      children: [
        // æœˆåº¦æ”¶å…¥å¡ç‰‡
        Text(
          "$month æœˆå‘¨æœŸæ”¶å…¥",
          style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: Colors.teal),
        ),
        const SizedBox(height: 15),
        Text(
          "Â¥ ${stats['total']!.toStringAsFixed(2)}",
          style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 20),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceAround,
          children: [
            _buildStatItem("åº•è–ª+ç»©æ•ˆ", "Â¥ ${(stats['base']! + stats['adds']!).toStringAsFixed(0)}", Colors.green),
            _buildStatItem("åŠ ç­è´¹", "Â¥ ${stats['overtime']!.toStringAsFixed(0)}", Colors.blue),
            _buildStatItem("æ€»æ‰£é™¤", "Â¥ ${stats['deduct']!.toStringAsFixed(0)}", Colors.red),
          ],
        ),
        
        const SizedBox(height: 30),
        const Divider(),
        const SizedBox(height: 20),

        // å¹´åº¦æ”¶å…¥å›¾è¡¨
        _buildLineChart(yearlySpots, maxY, "å¹´æ”¶å…¥è¶‹åŠ¿", (value) => "Â¥${(value / 1000).toStringAsFixed(0)}k", Colors.teal),
      ],
    );
  }
  
  // åŠ ç­è§†å›¾
  Widget _buildOvertimeView(Map<String, double> overtime, List<FlSpot> yearlySpots, double maxY, int month) {
    return Column(
      children: [
        // æœˆåº¦åŠ ç­å¡ç‰‡
        Text(
          "$month æœˆå‘¨æœŸåŠ ç­ç»Ÿè®¡",
          style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: Colors.teal),
        ),
        const SizedBox(height: 25),
        
        // ğŸ†• åŠ ç­å¤©æ•°ç»Ÿè®¡
        _buildStatItem("åŠ ç­å¤©æ•°", "${widget.overtimeDays} å¤©", Colors.blueGrey),
        const SizedBox(height: 20),

        // æ‰‡å½¢å›¾ï¼šå€ç‡åˆ†å¸ƒ
        _buildOvertimePieChart(overtime),

        const SizedBox(height: 30),
        const Divider(),
        const SizedBox(height: 20),

        // å¹´åº¦åŠ ç­å›¾è¡¨
        _buildLineChart(yearlySpots, maxY, "å¹´åŠ ç­è¶‹åŠ¿", (value) => "${value.toStringAsFixed(0)}h", Colors.deepOrange),
      ],
    );
}

// ğŸ†• æ–°å¢ï¼šåŠ ç­æ‰‡å½¢å›¾æ¸²æŸ“æ–¹æ³•
Widget _buildOvertimePieChart(Map<String, double> overtime) {
    final totalHours = overtime['total'] ?? 0;
    
    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæ˜¾ç¤ºæç¤º
    if (totalHours == 0) {
        return const SizedBox(
            height: 150,
            child: Center(
                child: Text("æœ¬æœˆæ— åŠ ç­æ•°æ®", style: TextStyle(color: Colors.grey)),
            ),
        );
    }
    
    // åˆ›å»º PieChartSectionData åˆ—è¡¨
    List<PieChartSectionData> sections = [];
    final colors = {
        '1.5x': const Color.fromARGB(255, 33, 171, 192),
        '2.0x': const Color.fromARGB(255, 20, 199, 88),
        '3.0x': const Color.fromARGB(255, 251, 56, 125),
    };
    
    overtime.forEach((key, hours) {
        if (key != 'total' && hours > 0) {
            
            // ğŸ†• ä¿®å¤ç‚¹ 1: ç§»é™¤æ‰‡åŒºä¸Šçš„ç™¾åˆ†æ¯”æ ‡ç­¾ (title) ä»¥é¿å…é‡å 
            sections.add(
                PieChartSectionData(
                    color: colors[key],
                    value: hours,
                    title: '', // ç§»é™¤æ ‡é¢˜
                    radius: 60,
                    // titleStyle: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold, color: Colors.white), // æ ‡é¢˜è¢«ç§»é™¤ï¼Œè¿™è¡Œå¯ä»¥åˆ æ‰
                ),
            );
        }
    });

    return SizedBox(
      // å¢åŠ é«˜åº¦ä»¥å®¹çº³å›¾ä¾‹
      height: 250, 
      child: Column(
        children: [
          // æ‰‡å½¢å›¾åŒºåŸŸ
          Expanded(
            child: PieChart(
              PieChartData(
                sectionsSpace: 2,
                centerSpaceRadius: 40,
                startDegreeOffset: -90,
                sections: sections,
              ),
            ),
          ),
          
          // ğŸ†• ä¿®å¤ç‚¹ 2: å¢åŠ å›¾ä¾‹å’Œå›¾è¡¨ä¹‹é—´çš„é—´è·
          const SizedBox(height: 20), 
          
          // å›¾ä¾‹åŒºåŸŸ
          Wrap(
            spacing: 16, // å¢åŠ å›¾ä¾‹é¡¹ä¹‹é—´çš„æ°´å¹³é—´è·
            runSpacing: 8, // å¢åŠ å›¾ä¾‹é¡¹ä¹‹é—´çš„å‚ç›´é—´è·
            alignment: WrapAlignment.center,
            children: overtime.entries.where((e) => e.key != 'total' && e.value > 0).map((entry) {
              final hours = entry.value;
              final percentage = (hours / totalHours) * 100;

              return Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(width: 10, height: 10, color: colors[entry.key]),
                  const SizedBox(width: 6),
                  // ğŸ†• ä¿®å¤ç‚¹ 3: å°†ç™¾åˆ†æ¯”å’Œå°æ—¶æ•°æ˜¾ç¤ºåœ¨å›¾ä¾‹ä¸­
                  Text(
                    '${entry.key}: ${hours.toStringAsFixed(1)}h (${percentage.toStringAsFixed(1)}%)', 
                    style: const TextStyle(fontSize: 12)
                  ),
                ],
              );
            }).toList(),
          ),
          const SizedBox(height: 10),
          Text(
            "æ€»åŠ ç­ï¼š${totalHours.toStringAsFixed(1)} å°æ—¶",
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
}
  // ç»Ÿä¸€çš„å›¾è¡¨æ¸²æŸ“æ–¹æ³•
  Widget _buildLineChart(List<FlSpot> spots, double maxY, String title, String Function(double) formatY, MaterialColor color) {
  return Column(
    children: [
      _buildYearSelector(title),
      const SizedBox(height: 15),
      SizedBox(
        height: 250,
        child: LineChart(
          LineChartData(
            minX: 1,
            maxX: 12,
            minY: 0,
            maxY: maxY,
            gridData: FlGridData(
              show: true,
              drawVerticalLine: true,
              getDrawingHorizontalLine: (value) => const FlLine(color: Colors.grey, strokeWidth: 0.2),
              getDrawingVerticalLine: (value) => const FlLine(color: Colors.grey, strokeWidth: 0.2),
            ),
            titlesData: FlTitlesData(
              show: true,
              rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
              topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
              bottomTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  reservedSize: 30,
                  interval: 1,
                  getTitlesWidget: (value, meta) => Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text("${value.toInt()}æœˆ", style: const TextStyle(fontSize: 10)),
                  ),
                ),
              ),
              leftTitles: AxisTitles(
                sideTitles: SideTitles(
                  showTitles: true,
                  reservedSize: 40,
                  getTitlesWidget: (value, meta) {
                    if (value == 0) return const Text('');
                    return Text(formatY(value), style: const TextStyle(fontSize: 10));
                  },
                ),
              ),
            ),
            borderData: FlBorderData(show: true, border: Border.all(color: const Color(0xff37434d))),

            // æœ€æ–°ç‰ˆ fl_chart æ­£ç¡®å†™æ³•ï¼ˆé‡ç‚¹åœ¨è¿™é‡Œï¼ï¼‰
            lineTouchData: LineTouchData(
              enabled: true,
              touchTooltipData: LineTouchTooltipData(           // â† ç›´æ¥æ˜¯ LineTooltipData
                getTooltipColor: (LineBarSpot touchedSpot) => color.shade700.withOpacity(0.95),
                tooltipPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                fitInsideHorizontally: true,
                fitInsideVertically: true,
                getTooltipItems: (touchedSpots) {
                  return touchedSpots.map((spot) {
                    final value = spot.y;
                    final text = value >= 10000
                        ? '${(value / 10000).toStringAsFixed(1)}ä¸‡'
                        : NumberFormat('#,###').format(value.toInt());
                    return LineTooltipItem(
                      text,
                      const TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 16),
                    );
                  }).toList();
                },
              ),
            ),

            lineBarsData: [
              LineChartBarData(
                spots: spots,
                isCurved: true,
                color: color,
                barWidth: 3,
                isStrokeCapRound: true,
                dotData: FlDotData(
                  show: true,
                  getDotPainter: (spot, percent, bar, index) => FlDotCirclePainter(
                    radius: 5,
                    color: color.shade700,
                    strokeWidth: 3,
                    strokeColor: Colors.white,
                  ),
                ),
                belowBarData: BarAreaData(show: true, color: color.withOpacity(0.25)),
              ),
            ],
          ),
        ),
      ),
    ],
  );
}

  // è¾…åŠ©å‡½æ•° (ç”¨äºä¸»åˆ‡æ¢æŒ‰é’®)
  Widget _buildTabBtn(String label, bool active, VoidCallback onTap) {
    return Expanded(
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          alignment: Alignment.center,
          padding: const EdgeInsets.symmetric(vertical: 8),
          decoration: BoxDecoration(
            color: active ? Colors.white : Colors.transparent,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Text(
            label, 
            style: TextStyle(
              fontWeight: FontWeight.bold, 
              color: active ? Colors.teal.shade800 : Colors.grey.shade600
            )
          ),
        ),
      ),
    );
  }
}
